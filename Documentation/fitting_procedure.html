<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4. Fitting the Gaussian &#8212; Alpaga 1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=61243dd2"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Polarisation Procedure" href="polarisation_procedure.html" />
    <link rel="prev" title="3. Cleaning and Averaging Spectra" href="cleaning_averaging_spectra.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <blockquote>
<div></div></blockquote>
<section id="fitting-the-gaussian">
<span id="fitting-procedure-page"></span><h1><span class="section-number">4. </span>Fitting the Gaussian<a class="headerlink" href="#fitting-the-gaussian" title="Link to this heading">¶</a></h1>
<p>In this page, we explain how to extract the Gaussian intensity from a spectrum.
This procedure has been optimized to minimize user choices and make the process as reproducible as possible.
Small changes in the procedure’s parameters can lead to variations in the extracted intensity.
Therefore, several methods are available: it is up to you to choose the one you prefer, and to document which one you used!</p>
<p>This procedure is explained in Part II of the <em>tutorial_spectra_analysis</em> tutorial.</p>
<a class="reference internal image-reference" href="_images/alpaga_2.jpg"><img alt="_images/alpaga_2.jpg" class="align-right" src="_images/alpaga_2.jpg" style="width: 350px;" />
</a>
<p>First, note that the background around your Gaussian is most likely not flat.
For example, due to sample fluorescence, a large noise component may appear, making Gaussian intensity extraction more difficult.
The first step is therefore to remove this background noise.</p>
<p>Once the background has been removed, the Gaussian intensity can be extracted using different methods: either a curve fit or an integral procedure.</p>
<p>In this page, we assume that the averaged and cleaned spectrum is provided as input (called the <em>y values</em>), along with the wave numbers (called the <em>x values</em>).
See <a class="reference internal" href="cleaning_averaging_spectra.html#cleaning-averaging-spectra-page"><span class="std std-ref">Cleaning and Averaging Spectra</span></a> for more details.
Note that the units of the x and y values do not matter, as long as they are consistent and within a reasonable range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If your curve is Lorentzian, you can still use the noise-removal step.
However, you will then need to fit the intensity manually.
Contact us if you would like to contribute a new Lorentzian fitting procedure to Alpaga.</p>
</div>
<section id="remove-the-noise">
<h2><span class="section-number">4.1. </span>Remove the noise<a class="headerlink" href="#remove-the-noise" title="Link to this heading">¶</a></h2>
<a class="reference internal image-reference" href="_images/alpaga_10.jpg" id="remove-noise-section"><img alt="_images/alpaga_10.jpg" class="align-left" id="remove-noise-section" src="_images/alpaga_10.jpg" style="width: 300px;" />
</a>
<p>The spectrum is divided into three regions using the x values.
The first and last regions are used to define the noise, while the central region should contain the Gaussian peak.
The first and last regions must be large enough to be meaningfully fitted with a polynomial function.</p>
<ul class="simple">
<li><p>If the noise regions are too large, the Gaussian area may not be properly fitted, altering the final intensity.</p></li>
<li><p>If the noise regions are too small, the polynomial fit may be meaningless.</p></li>
</ul>
<p>A simple way to check this is to add or remove a point from the noise region: the final Gaussian intensity should remain unchanged.</p>
<a class="reference internal image-reference" href="_images/l_cut_definition.png"><img alt="_images/l_cut_definition.png" class="align-center" src="_images/l_cut_definition.png" style="width: 600px;" />
</a>
<p>For the polynomial order used to fit the noise, we recommend 2, 3, or 4.
Lower orders are not suitable since the noise is rarely linear.
Higher orders may work but can introduce oscillations in the Gaussian region.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">analyze_run.</span></span><span class="sig-name descname"><span class="pre">remove_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[380,</span> <span class="pre">395,</span> <span class="pre">419,</span> <span class="pre">433]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_fit_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_fit_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figure_counter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/analyze_run.html#remove_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Remove the noise from a spectrum to make the Gaussian fit easier.</p>
<p>The x-axis is given by <em>L_x</em> and the y-axis by <em>L_y</em>. Using the list <em>l_cut</em>, the spectrum is divided into three areas.
The first area is from <em>l_cut[0]</em> to <em>l_cut[1]</em>, the second from <em>l_cut[1]</em> to <em>l_cut[2]</em>, and the third from <em>l_cut[2]</em> to <em>l_cut[3]</em>.
The second area is the target area where the Gaussian is expected. The first and third areas are used to define the noise in the target area using a polynomial fit.</p>
<p>This function first identifies the elements of the x-axis that correspond to the three areas.
To obtain these elements, set the optional parameter <em>return_boundary</em> to True. The function will then return the list <em>x_cut</em>, which can be used as follows to define the three areas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L_y_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>  <span class="c1"># first and last areas</span>
<span class="n">L_y_target</span> <span class="o">=</span> <span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>  <span class="c1"># middle area containing the Gaussian</span>
</pre></div>
</div>
<p>Next, the first and last areas are fitted using a polynomial of order specified by the optional parameter <em>order_fit_noise</em>.
To obtain the fitted noise, set <em>return_fit_noise</em> to True. The function will then return <em>L_y_noise_fit</em>, which contains the polynomial values calculated over all three areas.</p>
<p>Finally, the fitted noise is subtracted from all three areas. The first and last areas should be close to zero, while the middle area should contain a clean Gaussian.
If this is not the case, try adjusting the <em>l_cut</em> values to achieve a better noise fit.</p>
<p>To plot the three areas and the polynomial fit, set <em>show_spectra</em> to ‘all’. The initial figure number is given by <em>figure_counter</em>.</p>
<p>The first returned list is <em>L_x_cleaned</em>, the x-axis starting from <em>l_cut[0]</em> to <em>l_cut[3]</em>.
The second returned list is <em>L_y_cleaned</em>, the y-values with the noise subtracted, matching the size of <em>L_x_cleaned</em>.</p>
<p>If <em>return_fit_noise</em> is True, the list <em>L_y_noise_fit</em> containing the polynomial fit is returned.</p>
<p>If <em>return_boundary</em> is True, the list <em>x_cut</em>, containing the positions of the <em>l_cut</em> values in the original x-axis, is returned.</p>
<p>In all cases, the last returned value is an integer, the next figure number for plotting, ensuring no conflicts with existing figures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L_x</strong> (<em>list</em>) – The x-axis used to define the three areas.</p></li>
<li><p><strong>L_y</strong> (<em>list</em>) – The y-axis from which the noise will be removed.</p></li>
<li><p><strong>l_cut</strong> (<em>list</em><em> of </em><em>float</em>) – [Optional] Defines the three areas based on the values in <em>L_x</em>. Use actual x-values, not indices.</p></li>
<li><p><strong>order_fit_noise</strong> (<em>int</em>) – [Optional] Polynomial order for fitting the noise. Recommended values are 2, 3, or 4. The order has minimal impact if <em>l_cut</em> is well chosen.</p></li>
<li><p><strong>return_fit_noise</strong> (<em>bool</em>) – [Optional] If True, returns the noise fitted by a polynomial, <em>L_y_noise_fit</em>.</p></li>
<li><p><strong>return_boundary</strong> (<em>bool</em>) – [Optional] If True, returns <em>x_cut</em>, containing the element positions for defining the three areas.</p></li>
<li><p><strong>show_spectra</strong> (<em>str</em>) – [Optional] If ‘all’, plots the areas and polynomial fit.</p></li>
<li><p><strong>figure_counter</strong> (<em>int</em>) – [Optional] The starting figure number for plots.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>L_x_cleaned</strong> (<em>list</em>) – The x-axis corresponding to the three areas.</p></li>
<li><p><strong>L_y_cleaned</strong> (<em>list</em>) – The y-values with noise removed, same length as <em>L_x_cleaned</em>.</p></li>
<li><p><strong>L_y_noise_fit</strong> (<em>list</em>) – The polynomial-fitted noise, returned if <em>return_fit_noise</em> is True.</p></li>
<li><p><strong>x_cut</strong> (<em>list</em>) – Positions defining the boundaries of the three areas, returned if <em>return_boundary</em> is True.</p></li>
<li><p><strong>figure_counter</strong> (<em>int</em>) – The next figure number for plotting.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>See the tutorial for detailed examples. Example outputs depending on optional parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">alpaga</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">return_fit_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">L_y_noise_fit</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">alpaga</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">return_fit_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">x_cut</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">alpaga</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">return_fit_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">L_y_noise_fit</span><span class="p">,</span> <span class="n">x_cut</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">alpaga</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">return_fit_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: All arguments must be defined prior in the code, see the tutorial.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If noise removal worked correctly, the first and last regions should be flat and close to zero on average.
Most importantly, there should be no curvature: otherwise the Gaussian fit below will return incorrect values.
If you cannot achieve flat first and last regions, try reducing their size (e.g., set them to 10 nm).</p>
</div>
<a class="reference internal image-reference" href="_images/gaussian_distribution_meme.png"><img alt="_images/gaussian_distribution_meme.png" class="align-right" src="_images/gaussian_distribution_meme.png" style="width: 200px;" />
</a>
</section>
<section id="gaussian-intensity-extraction">
<h2><span class="section-number">4.2. </span>Gaussian intensity extraction<a class="headerlink" href="#gaussian-intensity-extraction" title="Link to this heading">¶</a></h2>
<p id="gaussian-fit-section">Once the background has been removed, the Gaussian spectrum should be much easier to fit.
There are two ways to extract the Gaussian intensity: fitting a Gaussian function or using an integral method.</p>
<a class="reference internal image-reference" href="_images/gaussian_fit.png"><img alt="_images/gaussian_fit.png" class="align-center" src="_images/gaussian_fit.png" style="width: 600px;" />
</a>
<ol class="arabic">
<li><p>Gaussian fit</p>
<blockquote>
<div><p>This method fits the curve with a Gaussian function:</p>
<div class="math notranslate nohighlight">
\[f(x) = I_0 \exp \left[ - \left( \frac{ x - \lambda_0}{w_0} \right)^2 \right]\]</div>
<p>and returns the intensity <span class="math notranslate nohighlight">\(I_0\)</span>, the peak position <span class="math notranslate nohighlight">\(\lambda_0\)</span>, and the waist <span class="math notranslate nohighlight">\(w_0\)</span>.
This function is defined in <em>alpaga.fit_gausse</em>.</p>
</div></blockquote>
</li>
<li><p>Integral method</p>
<blockquote>
<div><p>This method assumes that the peak position and waist are known, and extracts the intensity using the integral:</p>
<div class="math notranslate nohighlight">
\[f(x) = I_0 \exp \left[ - \left( \frac{ x - \lambda_0}{w_0} \right)^2 \right]
\int_{-\infty}^{+ \infty} f(x) dx = I_0 w_0 \sqrt \pi\]</div>
<p>The integral is implemented in <em>alpaga.intensity_from_gaussian_integral</em>, which returns the intensity.</p>
</div></blockquote>
</li>
</ol>
<a class="reference internal image-reference" href="_images/alpaga_3.jpg"><img alt="_images/alpaga_3.jpg" class="align-center" src="_images/alpaga_3.jpg" style="width: 300px;" />
</a>
<p>The function <em>alpaga.fit_gausse</em> defines the Gaussian described above.
It does not perform the fit itself (see below), but simply returns a Gaussian value for given x and parameters.
You can use this function to verify how Gaussian intensity is defined in Alpaga.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">analyze_run.</span></span><span class="sig-name descname"><span class="pre">fit_gausse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">waist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/analyze_run.html#fit_gausse"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function used to define the Gaussian shape in Alpaga.</p>
<p>y = intensity * np.exp(-((x - lambda_0) / waist) ** 2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list</em>) – The x values.</p></li>
<li><p><strong>intensity</strong> (<em>float</em>) – The Gaussian intensity, the parameter targeted by the whole procedure.</p></li>
<li><p><strong>lambda_0</strong> (<em>float</em>) – The position of the Gaussian maximum.</p></li>
<li><p><strong>waist</strong> (<em>float</em>) – The waist of the Gaussian.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y</strong> – The computed Gaussian values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<p>The function used to extract the intensity with the integral method is:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">analyze_run.</span></span><span class="sig-name descname"><span class="pre">intensity_from_gaussian_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L_x_cleaned</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y_cleaned</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">waist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/analyze_run.html#intensity_from_gaussian_integral"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Extract the Gaussian intensity using the integration method.
The integral is computed using the numpy.trapz function.
The intensity is then given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I0</span> <span class="o">=</span> <span class="n">integral_value</span> <span class="o">/</span> <span class="p">(</span><span class="n">waist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that in this procedure, no uncertainty calculations are yet implemented.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L_x_cleaned</strong> (<em>list</em>) – The x-axis used to compute the integral.
This axis should contain at least the Gaussian peak.</p></li>
<li><p><strong>L_y_cleaned</strong> (<em>list</em>) – The y-axis used to compute the integral.
Usually, this is the output obtained from the <a class="reference internal" href="#remove-noise-section"><span class="std std-ref">alpaga.remove_noise function</span></a>.
Apart from the Gaussian curve, the other values should be as close to zero as possible.
Since the integration is performed over the entire list, non-zero values may affect the final intensity if their average is not zero.</p></li>
<li><p><strong>lambda_0</strong> (<em>float</em>) – Unused. This input is kept only for consistency with other methods.</p></li>
<li><p><strong>waist</strong> (<em>float</em>) – The waist of the Gaussian, used to extract the Gaussian intensity from the integral value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>I0</strong> – The computed Gaussian intensity.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<p>The Gaussian fit method is more versatile: it provides not only the intensity but also the waist and peak position.
However, because it relies on fitting the entire curve, it can be less accurate when the signal is weak.</p>
<p>The integral method, on the other hand, is often more robust for intensity extraction, but it requires prior knowledge of the waist.
For well-behaved Gaussian curves, both methods yield the same result.
Since it is unclear which method is most precise, both are always available.</p>
<p>The Gaussian intensity extraction function also relies on <em>alpaga.remove_noise</em> to remove the background.
If your curve is already noise-free, this step should not be a problem.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">analyze_run.</span></span><span class="sig-name descname"><span class="pre">fit_gaussian_from_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[380,</span> <span class="pre">395,</span> <span class="pre">419,</span> <span class="pre">433]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_fit_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fit_gauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds_fit_gausse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">([0,</span> <span class="pre">395,</span> <span class="pre">1],</span> <span class="pre">[inf,</span> <span class="pre">410,</span> <span class="pre">25])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_0_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">403</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">waist_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclu_zone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figure_counter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/analyze_run.html#fit_gaussian_from_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>This function returns the intensity <em>I0</em>, the maximum position <em>lambda_0</em>, and the width <em>waist</em>
of the Gaussian in <em>L_y</em>. The procedure first removes the noise using
<a class="reference internal" href="#remove-noise-section"><span class="std std-ref">alpaga.remove_noise function</span></a>, and then extracts the intensity.
Two methods are available to extract the intensity:</p>
<ol class="arabic">
<li><p>If <em>method_fit</em> is set to ‘fit_gauss’:</p>
<blockquote>
<div><p>The intensity is extracted using <em>scipy.optimize.curve_fit</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">fit_gausse</span><span class="p">,</span> <span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds_fit_gausse</span><span class="p">)</span>
<span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, <em>fit_gausse</em> is defined in the analyze_run.fit_gausse function. The x and y inputs are the outputs of the cleaning
procedure (see <a class="reference internal" href="#remove-noise-section"><span class="std std-ref">analyze_run.remove_noise function</span></a>), and the bounds
are given by the <em>bounds_fit_gausse</em> parameter.
This method returns the Gaussian intensity <em>I0</em>, the central wavelength <em>lambda_0</em>, and the
width <em>waist</em>.
This approach is the most versatile and should generally be used first to characterize your
experimental laser conditions (<em>lambda_0</em> and <em>waist</em>).</p>
</div></blockquote>
</li>
<li><p>If <em>method_fit</em> is set to ‘fit_gauss_w_exclu’:</p>
<blockquote>
<div><p>Same method as above, but with an exclusion zone (for example, if a Hyper Raman band is close
to the SHG signal).
You must specify the exclusion zone with <em>exclu_zone = [X_min, X_max]</em>.</p>
</div></blockquote>
</li>
<li><p>If <em>method_fit</em> is set to ‘integral_gauss’:</p>
<blockquote>
<div><p>The intensity is extracted using <em>analyze_run.intensity_from_gaussian_integral</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I0</span> <span class="o">=</span> <span class="n">intensity_from_gaussian_integral</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <em>lambda_0</em> and <em>waist</em> are set by the parameters <em>lambda_0_ref</em> and <em>waist_ref</em>.
Note that <em>lambda_0_ref</em> does not affect the result (<em>I0</em>); it is only used for plotting.</p>
</div></blockquote>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L_x</strong> (<em>list</em>) – The x-axis data, used for noise removal and fitting.</p></li>
<li><p><strong>L_y</strong> (<em>list</em>) – The y-axis data where the Gaussian intensity should be extracted.</p></li>
<li><p><strong>l_cut</strong> (<em>list</em><em> of </em><em>float</em>) – [Optional] Parameters used for noise removal (see <a class="reference internal" href="#remove-noise-section"><span class="std std-ref">alpaga.remove_noise function</span></a>).</p></li>
<li><p><strong>order_fit_noise</strong> (<em>int</em>) – [Optional] Order of the polynomial used for noise removal.</p></li>
<li><p><strong>method_fit</strong> (<em>str</em>) – [Optional] The method used to extract the intensity once noise is removed.</p></li>
<li><p><strong>bounds_fit_gausse</strong> (<em>list</em>) – [Optional] Bounds for the free parameters in the ‘fit_gauss’ method.
Narrowing the parameter ranges avoids problems with low Gaussian intensity, where the fit
may increase the width instead of decreasing <em>I0</em>.
Example: to restrict <em>lambda_0</em> between 401 and 405, and <em>waist</em> between 2 and 3, use
<em>bounds_fit_gausse = ([0, 401, 1], [np.inf, 405, 3])</em>.
See <em>scipy.optimize.curve_fit</em> documentation for more details.</p></li>
<li><p><strong>lambda_0_ref</strong> (<em>float</em>) – [Optional] Reference value of <em>lambda_0</em> for the ‘integral_gauss’ method.
This has no impact on the result but affects plotting.</p></li>
<li><p><strong>waist_ref</strong> (<em>float</em>) – [Optional] Reference value of <em>waist</em> for the ‘integral_gauss’ method.
This has a direct impact on <em>I0</em>. Choose carefully (see <a class="reference internal" href="polarisation_procedure.html#polarisation-procedure-page"><span class="std std-ref">Polarisation Procedure</span></a>).</p></li>
<li><p><strong>exclu_zone</strong> (<em>list</em><em> of </em><em>float</em>) – [Optional] Pair of floats defining the exclusion zone for ‘fit_gauss_w_exclu’.</p></li>
<li><p><strong>show_spectra</strong> (<em>str</em>) – [Optional] If ‘all’, plots figures to check results. Otherwise, no figures are shown.</p></li>
<li><p><strong>figure_counter</strong> (<em>int</em>) – [Optional] The number assigned to the first figure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>L_para_gauss</strong> (<em>list</em>) – Gaussian parameters [I0, lambda_0, waist].
<em>I0</em>: Gaussian intensity
<em>lambda_0</em>: central wavelength
<em>waist</em>: Gaussian width</p></li>
<li><p><strong>L_err</strong> (<em>list</em>) – Associated errors [err_I0, err_lambda_0, err_waist].
No errors are defined for the ‘integral_gauss’ method; in this case, the error list contains zeros.</p></li>
<li><p><strong>figure_counter</strong> (<em>int</em>) – Updated figure counter for subsequent plots.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>See the tutorial for detailed examples. A minimal workflow is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the directory where the data are stored</span>
<span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">WORK_DIR</span><span class="p">,</span> <span class="s1">&#39;Eau_V_Spectres&#39;</span><span class="p">)</span>

<span class="c1"># Extract Alpaga parameters describing the dataset</span>
<span class="n">prefix_file</span><span class="p">,</span> <span class="n">L_files_angles</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">alpaga</span><span class="o">.</span><span class="n">find_angle_iter_from_dir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>

<span class="c1"># Select one acquisition</span>
<span class="n">names</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">prefix_file</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">L_files_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Clean the acquisition from spikes and average it over N_iter</span>
<span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">alpaga</span><span class="o">.</span><span class="n">averaging_and_cleaning</span><span class="p">(</span>
    <span class="n">names</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="n">type_cleaning</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
    <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span>
    <span class="n">show_spectra</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="c1"># Remove noise and extract Gaussian parameters</span>
<span class="n">intensity</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">Alpaga</span><span class="o">.</span><span class="n">analyze_run</span><span class="o">.</span><span class="n">fit_gaussian_from_noise</span><span class="p">(</span>
    <span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="p">[</span><span class="mi">380</span><span class="p">,</span> <span class="mi">399</span><span class="p">,</span> <span class="mi">414</span><span class="p">,</span> <span class="mi">431</span><span class="p">],</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">395</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">410</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span> <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;all&#39;</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">intensity</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="towards-automation">
<h2><span class="section-number">4.3. </span>Towards automation<a class="headerlink" href="#towards-automation" title="Link to this heading">¶</a></h2>
<a class="reference internal image-reference" href="_images/alpaga_7.jpg"><img alt="_images/alpaga_7.jpg" class="align-right" src="_images/alpaga_7.jpg" style="width: 300px;" />
</a>
<p>Extracting intensity from averaged spectra is perhaps the step where numerical parameters most strongly influence the results.
Therefore, we recommend:</p>
<ol class="arabic simple">
<li><p>Testing several parameters to see which best fit <strong>your</strong> data (some samples are easier to fit than others).</p></li>
<li><p>Using the <strong>same parameters</strong> consistently for all acquisitions.</p></li>
</ol>
<p>The fully automated procedure is presented in <a class="reference internal" href="polarisation_procedure.html#polarisation-procedure-page"><span class="std std-ref">Polarisation Procedure</span></a>.
It combines the approaches described in <a class="reference internal" href="file_management.html#file-management-page"><span class="std std-ref">File Management</span></a>, <a class="reference internal" href="cleaning_averaging_spectra.html#cleaning-averaging-spectra-page"><span class="std std-ref">Cleaning and Averaging Spectra</span></a>, and this page.</p>
<dl class="field-list simple">
<dt class="field-odd">Release<span class="colon">:</span></dt>
<dd class="field-odd"><p>1.2</p>
</dd>
<dt class="field-even">Date<span class="colon">:</span></dt>
<dd class="field-even"><p>Aug 24, 2025</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/alpaga_logo.svg" alt="Logo of Alpaga"/>
            </a></p>
<h1 class="logo"><a href="index.html">Alpaga</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">1. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_management.html">2. File Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="cleaning_averaging_spectra.html">3. Cleaning and Averaging Spectra</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Fitting the Gaussian</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#remove-the-noise">4.1. Remove the noise</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gaussian-intensity-extraction">4.2. Gaussian intensity extraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#towards-automation">4.3. Towards automation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="polarisation_procedure.html">5. Polarisation Procedure</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis_SHS.html">6. SHS analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis_SSHG.html">7. SSHG analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_advice.html">8. Python advice</a></li>
<li class="toctree-l1"><a class="reference internal" href="experimental_advice.html">9. Experimental and procedure advice</a></li>
<li class="toctree-l1"><a class="reference internal" href="for_developpers.html">10. For Developpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="devs_page.html">11. Alpaga’s developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">12. Reference</a></li>
</ul>


<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;L-GPL.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/fitting_procedure.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>