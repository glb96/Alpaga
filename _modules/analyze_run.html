<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>analyze_run &#8212; Alpaga 1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=61243dd2"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for analyze_run</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># Alpaga</span>
<span class="c1"># AnaLyse en PolArisation de la Generation de second hArmonique </span>

<span class="kn">import</span><span class="w"> </span><span class="nn">importlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">Alpaga.file_management</span><span class="w"> </span><span class="kn">import</span> <span class="n">standard_file_name</span> <span class="k">as</span> <span class="n">standard_file_name</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Alpaga.file_management</span><span class="w"> </span><span class="kn">import</span> <span class="n">third_floor_file_name_builder</span> <span class="k">as</span> <span class="n">third_floor_file_name_builder</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Alpaga.file_management</span><span class="w"> </span><span class="kn">import</span> <span class="n">transform_name_file</span> <span class="k">as</span> <span class="n">transform_name_file</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Alpaga.file_management</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_file_iter_from_dir</span> <span class="k">as</span> <span class="n">find_file_iter_from_dir</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Alpaga.file_management</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_angle_iter_from_dir</span> <span class="k">as</span> <span class="n">find_angle_iter_from_dir</span>

<span class="c1">############################################################################################</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">clear_output</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># fallback for normal Python environment</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">pass</span>  <span class="c1"># do nothing</span>
    
<span class="c1">############################################################################################</span>
    
<span class="c1">############################################################################################</span>
<span class="c1">####################### Cleaning and averaging spectra #####################################</span>
<span class="c1">############################################################################################</span>

<div class="viewcode-block" id="clean_spectra_mean_n">
<a class="viewcode-back" href="../cleaning_averaging_spectra.html#analyze_run.clean_spectra_mean_n">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">clean_spectra_mean_n</span><span class="p">(</span><span class="n">L_y</span><span class="p">,</span> <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect spikes in the list of data *L_y* using a local averaging method.  </span>
<span class="sd">    This method is designed to avoid removing features that are not actual spikes.  </span>
<span class="sd">    Instead of applying a single rough treatment, several small treatments are performed,  </span>
<span class="sd">    so that the spectra are affected as little as possible.  </span>

<span class="sd">    **Steps**</span>
<span class="sd">    </span>
<span class="sd">    1) For given *mean_cleaning_n* (integer) and *mean_cleaning_evo_max* (float),  </span>
<span class="sd">       the function scans the list *L_y* to clean.  </span>
<span class="sd">       For a value L_y[k], it computes the local average:</span>

<span class="sd">           ave_k = (L_y[k-mean_cleaning_n] + ... + L_y[k-1] + L_y[k+1] + ... + L_y[k+mean_cleaning_n]) / (2*mean_cleaning_n)</span>

<span class="sd">       i.e. the local average over 2*mean_cleaning_n neighbors, **excluding** the point k.</span>

<span class="sd">    2) The value L_y[k] is compared against mean_cleaning_evo_max × ave_k.  </span>
<span class="sd">       If L_y[k] is larger, it is considered a spike.  </span>
<span class="sd">       In this case, L_y[k] is replaced by ave_k **for the spike detection process only (not for the final analysis)**.  </span>
<span class="sd">       Spikes are stored in the list *L_population*: if L_population[k] = 0, point k is a spike, otherwise it is 1.  </span>
<span class="sd">       The averaging procedure will later use this list to remove the spikes.  </span>

<span class="sd">    3) For every *mean_cleaning_n* and *mean_cleaning_evo_max* declared in the input arguments  </span>
<span class="sd">       *L_mean_cleaning_n* and *L_mean_cleaning_evo_max*, steps (1) and (2) are repeated,  </span>
<span class="sd">       updating *L_y* when spikes are detected.  </span>

<span class="sd">    This multi-pass approach helps detect as many spikes as possible, while minimizing false positives.  </span>
<span class="sd">    A recommended strategy is to start with stricter parameters, and progressively decrease the threshold.  </span>
<span class="sd">    For example:  </span>

<span class="sd">        L_mean_cleaning_n = [1, 1, 1, 3]  </span>
<span class="sd">        L_mean_cleaning_evo_max = [2, 1.5, 1.2, 1.1]  </span>

<span class="sd">    performs 4 treatments.  </span>
<span class="sd">    The first 3 use only the two nearest neighbors (L_y[k-1] and L_y[k+1]) to compute the average.  </span>
<span class="sd">    In the first pass, a point is flagged as a spike if it is twice this local average.  </span>
<span class="sd">    In the second pass, the threshold is 1.5, then 1.2 in the third.  </span>
<span class="sd">    The final pass uses 6 neighbors and a 1.1 threshold.  </span>

<span class="sd">    This procedure was designed to catch spikes that may span 2–3 consecutive points (rare but possible).  </span>
<span class="sd">    It is recommended to experiment with *L_mean_cleaning_n* and *L_mean_cleaning_evo_max*  </span>
<span class="sd">    to ensure spikes are removed without altering the rest of the spectra.  </span>
<span class="sd">    For instance, try:  </span>

<span class="sd">        L_mean_cleaning_n = [1, 1, 1, 3]  </span>
<span class="sd">        L_mean_cleaning_evo_max = [2, 1.5, 1.1, 1.05]  </span>

<span class="sd">    to see the effect of overly strict parameters.  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L_y : list</span>
<span class="sd">        Data to clean.  </span>
<span class="sd">    L_mean_cleaning_n : list of int, optional</span>
<span class="sd">        List of neighborhood sizes for computing local averages.  </span>
<span class="sd">        Must have the same length as *L_mean_cleaning_evo_max*.  </span>
<span class="sd">    L_mean_cleaning_evo_max : list of float, optional</span>
<span class="sd">        List of maximum coefficients used for spike detection.  </span>
<span class="sd">        Values should generally be between 1.1 and 2–3.  </span>
<span class="sd">        A point is flagged as a spike if L_y[k] &gt; coeff × local average.  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L_population : list</span>
<span class="sd">        List of the same size as *L_y*, initialized to 1.  </span>
<span class="sd">        If a spike is detected at position k, then L_population[k] = 0.  </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For practical usage, see :ref:`alpaga.averaging_and_cleaning function&lt;averaging_spectra_section&gt;`.  </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A Fourier-based cleaning method may be added in the future if requested.  </span>
<span class="sd">    However, for short acquisition times, it may distort the spectra.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L_y_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_y</span><span class="p">)</span>
    <span class="n">L_population</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Redefine the value if the old input type is used.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_mean_cleaning_n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">L_mean_cleaning_n</span> <span class="o">=</span> <span class="p">[</span><span class="n">L_mean_cleaning_n</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_mean_cleaning_evo_max</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_mean_cleaning_evo_max</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: If only one cleaning is required, both L_mean_cleaning_n and L_mean_cleaning_evo_max should be int or float. You should also define them as a list with a single element. Example: L_mean_cleaning_n = [3] and L_mean_cleaning_evo_max = [1.4].&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L_mean_cleaning_evo_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">L_mean_cleaning_evo_max</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_mean_cleaning_n</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_mean_cleaning_evo_max</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: If several cleanings are required, both L_mean_cleaning_n and L_mean_cleaning_evo_max should be lists.&#39;</span><span class="p">)</span>

    <span class="n">N_cleaning</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_mean_cleaning_n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">N_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_cleaning</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">mean_cleaning_n_t</span> <span class="o">=</span> <span class="n">L_mean_cleaning_n</span><span class="p">[</span><span class="n">N_c</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mean_cleaning_n_t</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: Every element of L_mean_cleaning_n should be an int!&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mean_cleaning_n_t</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_y</span><span class="p">)</span><span class="o">-</span><span class="n">mean_cleaning_n_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mean_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_y_clean</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">mean_cleaning_n_t</span><span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L_y_clean</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">mean_cleaning_n_t</span><span class="p">]))</span> <span class="c1"># mean without the point k</span>
            <span class="k">if</span> <span class="n">L_y_clean</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mean_t</span> <span class="o">*</span> <span class="n">L_mean_cleaning_evo_max</span><span class="p">[</span><span class="n">N_c</span><span class="p">]:</span>
                <span class="n">L_y_clean</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_t</span>
                <span class="n">L_population</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">L_population</span></div>



<span class="c1">############################################################################################</span>

<div class="viewcode-block" id="averaging_and_cleaning">
<a class="viewcode-back" href="../cleaning_averaging_spectra.html#analyze_run.averaging_and_cleaning">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">averaging_and_cleaning</span><span class="p">(</span><span class="n">name_file</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">,</span> <span class="n">L_filename</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span>
                           <span class="n">fct_name</span><span class="o">=</span><span class="n">standard_file_name</span><span class="p">,</span> <span class="n">type_cleaning</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                           <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span>
                           <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a set of acquisitions with filenames:</span>
<span class="sd">    </span>
<span class="sd">        *name_file* + &#39;_&#39; + i + *extension*,</span>
<span class="sd">    </span>
<span class="sd">    return the mean spectra cleaned of spikes. Currently, only one type of averaging and cleaning is available through *type_cleaning*, which is &#39;mean&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Each acquisition i is processed using the function :func:`alpaga.clean_spectra_mean_n` </span>
<span class="sd">    with optional arguments *L_mean_cleaning_n* and *L_mean_cleaning_evo_max*, see :ref:`cleaning_averaging_spectra_page` </span>
<span class="sd">    for details. Spikes are detected for each spectrum, and the mean is computed element-wise over all acquisitions, ignoring the spikes.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    If there are 4 acquisitions, for the k-th element (e.g., wavelength 404 nm):</span>
<span class="sd">    </span>
<span class="sd">        - If no spikes are detected for all 4 acquisitions, the average is the mean of all 4 values.</span>
<span class="sd">        - If the second acquisition has a spike at this element, the average ignores the second acquisition **only for this element**.</span>
<span class="sd">        - If all 4 acquisitions have a spike at this element, it may indicate:</span>
<span class="sd">            * Detection parameters are too strict: decrease values in *L_mean_cleaning_evo_max*.</span>
<span class="sd">            * Acquisition time per spectrum is too long, increasing spike probability.</span>
<span class="sd">            * A serious detector issue or other abnormality (e.g., ISS data). </span>
<span class="sd">    </span>
<span class="sd">    In such cases, a warning is printed, and the mean value is used for that element, but acquisition parameters should be reconsidered.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name_file : str</span>
<span class="sd">        Prefix for all acquisition filenames. Use absolute paths; see :ref:`file_management_page` for more details.</span>
<span class="sd">    N_iter : int or list of int</span>
<span class="sd">        Number of acquisitions to average. If a list is provided, only those iterations are processed.</span>
<span class="sd">    L_filename : bool or list of str</span>
<span class="sd">        If a list is provided, contains the absolute filenames to process, bypassing generated filenames.</span>
<span class="sd">    extension : str</span>
<span class="sd">        [Optional] File extension for data files.</span>
<span class="sd">    fct_name : function</span>
<span class="sd">        [Optional] Function used to generate a filename from prefix, iteration, and extension. Defaults to :func:`alpaga.standard_file_name`.</span>
<span class="sd">    type_cleaning : str</span>
<span class="sd">        [Optional] Currently only &#39;mean&#39; is supported.</span>
<span class="sd">    L_mean_cleaning_n : list</span>
<span class="sd">        [Optional] See :func:`alpaga.clean_spectra_mean_n` for details.</span>
<span class="sd">    L_mean_cleaning_evo_max : list</span>
<span class="sd">        [Optional] See :func:`alpaga.clean_spectra_mean_n` for details.</span>
<span class="sd">    show_spectra : str</span>
<span class="sd">        [Optional] &#39;average&#39; plots only the final averaged spectra, &#39;all&#39; also plots spike detection for each iteration. Any other value disables plotting.</span>
<span class="sd">    figure_counter : int</span>
<span class="sd">        [Optional] Number of the first figure for plotting.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L_x_axis : list</span>
<span class="sd">        X-axis values from the spectra files.</span>
<span class="sd">    L_spectra_t : list</span>
<span class="sd">        Averaged and cleaned spectra.</span>
<span class="sd">    figure_counter : int</span>
<span class="sd">        Updated figure counter for subsequent plots.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ::</span>
<span class="sd">    </span>
<span class="sd">       names = &#39;Spectra_4.0&#39;</span>
<span class="sd">       N_iter = 4</span>
<span class="sd">       L_lambda, L_spectra, _ = alpaga.averaging_and_cleaning(</span>
<span class="sd">           names, N_iter, extension=&#39;.dat&#39;, type_cleaning=&#39;mean&#39;,</span>
<span class="sd">           L_mean_cleaning_n=[1, 1, 1, 3], L_mean_cleaning_evo_max=[2, 1.5, 1.2, 1.1],</span>
<span class="sd">           show_spectra=&#39;all&#39;, figure_counter=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_filename</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">L_filename</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: L_filename is not defined correctly. It should be a non-empty list of strings!&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_iter</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">L_iter</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_iter</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Averaging will be done for iterations from 1 to&#39;</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_iter</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">L_iter</span> <span class="o">=</span> <span class="n">N_iter</span>
        <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Averaging will be done for iterations:&#39;</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_filename</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">L_filename</span><span class="p">:</span>
        <span class="n">name_file_t</span> <span class="o">=</span> <span class="n">L_filename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">name_file_t</span> <span class="o">=</span> <span class="n">fct_name</span><span class="p">(</span><span class="n">name_file</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">L_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">extension</span><span class="o">=</span><span class="n">extension</span><span class="p">)</span>
        
    <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">name_file_t</span><span class="p">)</span>
    <span class="n">L_x_axis</span> <span class="o">=</span> <span class="n">spectra</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_lambda</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_x_axis</span><span class="p">)</span>
        
    <span class="c1"># Mean-type cleaning</span>
    <span class="k">if</span> <span class="n">type_cleaning</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">L_population_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_lambda</span><span class="p">)</span>
        <span class="n">L_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">L_iter</span><span class="p">),</span> <span class="n">n_lambda</span><span class="p">))</span>
        <span class="n">L_spectra_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_lambda</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_iter</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_filename</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">L_filename</span><span class="p">:</span>
                <span class="n">name_file_t</span> <span class="o">=</span> <span class="n">L_filename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">name_file_t</span> <span class="o">=</span> <span class="n">fct_name</span><span class="p">(</span><span class="n">name_file</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">L_iter</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">extension</span><span class="o">=</span><span class="n">extension</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">name_file_t</span><span class="p">)</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">name_file_t</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">name_file</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">L_iter</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_axis</span><span class="p">,</span> <span class="n">spectra</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="n">L_population</span> <span class="o">=</span> <span class="n">clean_spectra_mean_n</span><span class="p">(</span>
                <span class="n">spectra</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="n">L_mean_cleaning_n</span><span class="p">,</span>
                <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="n">L_mean_cleaning_evo_max</span>
            <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_population</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">L_population</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">L_x_axis</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="p">[</span><span class="n">spectra</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]],</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
                <span class="n">figure_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">L_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectra</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_population</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">L_population</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">L_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">L_population_t</span> <span class="o">+=</span> <span class="n">L_population</span>
            
        <span class="n">L_to_correct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_population_t</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">L_population_t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: For files with prefix </span><span class="si">{</span><span class="n">name_file</span><span class="si">}</span><span class="s1">, a spike was detected at lambda </span><span class="si">{</span><span class="n">L_x_axis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="si">}</span><span class="s1"> for all iterations! The returned value may not be meaningful.&#39;</span><span class="p">)</span>
                <span class="n">L_population_t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">L_to_correct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_iter</span><span class="p">)):</span>
            <span class="n">L_spectra_t</span> <span class="o">+=</span> <span class="n">L_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
        <span class="n">L_spectra_t</span> <span class="o">/=</span> <span class="n">L_population_t</span>
            
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">L_to_correct</span><span class="p">:</span>  <span class="c1"># Avoid zeros in spectra</span>
            <span class="n">borne_min</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">borne_max</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">L_spectra_t</span><span class="p">[</span><span class="n">borne_min</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">borne_min</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">L_spectra_t</span><span class="p">[</span><span class="n">borne_max</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">borne_max</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">L_spectra_t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">L_spectra_t</span><span class="p">[</span><span class="n">borne_min</span><span class="p">]</span> <span class="o">+</span> <span class="n">L_spectra_t</span><span class="p">[</span><span class="n">borne_max</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">show_spectra</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">]:</span> 
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">name_file</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_axis</span><span class="p">,</span> <span class="n">L_spectra_t</span><span class="p">)</span>
        <span class="n">figure_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">L_x_axis</span><span class="p">,</span> <span class="n">L_spectra_t</span><span class="p">,</span> <span class="n">figure_counter</span></div>


        
<span class="c1">############################################################################################</span>
<span class="c1">################################# Fit and noise   ##########################################</span>
<span class="c1">############################################################################################    </span>

<div class="viewcode-block" id="remove_noise">
<a class="viewcode-back" href="../fitting_procedure.html#analyze_run.remove_noise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_noise</span><span class="p">(</span><span class="n">L_x</span><span class="p">,</span> <span class="n">L_y</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="p">[</span><span class="mi">380</span><span class="p">,</span> <span class="mi">395</span><span class="p">,</span> <span class="mi">419</span><span class="p">,</span> <span class="mi">433</span><span class="p">],</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">return_fit_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="kc">False</span> <span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Remove the noise from a spectrum to make the Gaussian fit easier.</span>
<span class="sd">    </span>
<span class="sd">    The x-axis is given by *L_x* and the y-axis by *L_y*. Using the list *l_cut*, the spectrum is divided into three areas. </span>
<span class="sd">    The first area is from *l_cut[0]* to *l_cut[1]*, the second from *l_cut[1]* to *l_cut[2]*, and the third from *l_cut[2]* to *l_cut[3]*. </span>
<span class="sd">    The second area is the target area where the Gaussian is expected. The first and third areas are used to define the noise in the target area using a polynomial fit.</span>
<span class="sd">    </span>
<span class="sd">    This function first identifies the elements of the x-axis that correspond to the three areas. </span>
<span class="sd">    To obtain these elements, set the optional parameter *return_boundary* to True. The function will then return the list *x_cut*, which can be used as follows to define the three areas: ::</span>
<span class="sd">        </span>
<span class="sd">        L_y_noise = np.append(L_y[x_cut[0]:x_cut[1]], L_y[x_cut[2]:x_cut[3]])  # first and last areas</span>
<span class="sd">        L_y_target = L_y[x_cut[1]:x_cut[2]]  # middle area containing the Gaussian</span>
<span class="sd">    </span>
<span class="sd">    Next, the first and last areas are fitted using a polynomial of order specified by the optional parameter *order_fit_noise*. </span>
<span class="sd">    To obtain the fitted noise, set *return_fit_noise* to True. The function will then return *L_y_noise_fit*, which contains the polynomial values calculated over all three areas.</span>
<span class="sd">    </span>
<span class="sd">    Finally, the fitted noise is subtracted from all three areas. The first and last areas should be close to zero, while the middle area should contain a clean Gaussian. </span>
<span class="sd">    If this is not the case, try adjusting the *l_cut* values to achieve a better noise fit.</span>
<span class="sd">    </span>
<span class="sd">    To plot the three areas and the polynomial fit, set *show_spectra* to &#39;all&#39;. The initial figure number is given by *figure_counter*.</span>
<span class="sd">    </span>
<span class="sd">    The first returned list is *L_x_cleaned*, the x-axis starting from *l_cut[0]* to *l_cut[3]*.</span>
<span class="sd">    The second returned list is *L_y_cleaned*, the y-values with the noise subtracted, matching the size of *L_x_cleaned*.</span>
<span class="sd">    </span>
<span class="sd">    If *return_fit_noise* is True, the list *L_y_noise_fit* containing the polynomial fit is returned.</span>
<span class="sd">    </span>
<span class="sd">    If *return_boundary* is True, the list *x_cut*, containing the positions of the *l_cut* values in the original x-axis, is returned.</span>
<span class="sd">    </span>
<span class="sd">    In all cases, the last returned value is an integer, the next figure number for plotting, ensuring no conflicts with existing figures.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L_x: list</span>
<span class="sd">        The x-axis used to define the three areas.</span>
<span class="sd">    L_y: list</span>
<span class="sd">        The y-axis from which the noise will be removed.</span>
<span class="sd">    l_cut: list of float</span>
<span class="sd">        [Optional] Defines the three areas based on the values in *L_x*. Use actual x-values, not indices.</span>
<span class="sd">    order_fit_noise: int</span>
<span class="sd">        [Optional] Polynomial order for fitting the noise. Recommended values are 2, 3, or 4. The order has minimal impact if *l_cut* is well chosen.</span>
<span class="sd">    return_fit_noise: bool</span>
<span class="sd">        [Optional] If True, returns the noise fitted by a polynomial, *L_y_noise_fit*.</span>
<span class="sd">    return_boundary: bool</span>
<span class="sd">        [Optional] If True, returns *x_cut*, containing the element positions for defining the three areas.</span>
<span class="sd">    show_spectra: str</span>
<span class="sd">        [Optional] If &#39;all&#39;, plots the areas and polynomial fit.</span>
<span class="sd">    figure_counter: int</span>
<span class="sd">        [Optional] The starting figure number for plots.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L_x_cleaned: list</span>
<span class="sd">        The x-axis corresponding to the three areas.</span>
<span class="sd">    L_y_cleaned: list</span>
<span class="sd">        The y-values with noise removed, same length as *L_x_cleaned*.</span>
<span class="sd">    L_y_noise_fit: list</span>
<span class="sd">        The polynomial-fitted noise, returned if *return_fit_noise* is True.</span>
<span class="sd">    x_cut: list</span>
<span class="sd">        Positions defining the boundaries of the three areas, returned if *return_boundary* is True.</span>
<span class="sd">    figure_counter: int</span>
<span class="sd">        The next figure number for plotting.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See the tutorial for detailed examples. Example outputs depending on optional parameters: ::</span>
<span class="sd">    </span>
<span class="sd">        L_x_cleaned, L_y_cleaned, figure_counter = alpaga.remove_noise(L_lambda, L_spectra, l_cut=l_cut, order_fit_noise=order_fit_noise, return_fit_noise=False, return_boundary=False, show_spectra=&#39;all&#39;, figure_counter=1)</span>
<span class="sd">        L_x_cleaned, L_y_cleaned, L_y_noise_fit, figure_counter = alpaga.remove_noise(L_lambda, L_spectra, l_cut=l_cut, order_fit_noise=order_fit_noise, return_fit_noise=True, return_boundary=False, show_spectra=&#39;all&#39;, figure_counter=1)</span>
<span class="sd">        L_x_cleaned, L_y_cleaned, x_cut, figure_counter = alpaga.remove_noise(L_lambda, L_spectra, l_cut=l_cut, order_fit_noise=order_fit_noise, return_fit_noise=False, return_boundary=True, show_spectra=&#39;all&#39;, figure_counter=1)</span>
<span class="sd">        L_x_cleaned, L_y_cleaned, L_y_noise_fit, x_cut, figure_counter = alpaga.remove_noise(L_lambda, L_spectra, l_cut=l_cut, order_fit_noise=order_fit_noise, return_fit_noise=True, return_boundary=True, show_spectra=&#39;all&#39;, figure_counter=1)</span>
<span class="sd">    </span>
<span class="sd">    Note: All arguments must be defined prior in the code, see the tutorial.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># find where to make the cut to define the noise</span>
    <span class="n">N_lambda</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_x</span><span class="p">)</span>
    <span class="n">KKK</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">trotter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">trotter</span><span class="o">&lt;</span><span class="mi">4</span> <span class="ow">or</span> <span class="n">KKK</span><span class="o">&gt;</span><span class="n">N_lambda</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">L_x</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l_cut</span><span class="p">[</span><span class="n">trotter</span><span class="p">]:</span>
            <span class="n">x_cut</span><span class="p">[</span><span class="n">trotter</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">KKK</span><span class="p">)</span>
            <span class="n">trotter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">KKK</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">L_x_cleaned</span> <span class="o">=</span> <span class="n">L_x</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
    <span class="c1"># Fit the noise:</span>
    <span class="n">L_x_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_x</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">L_x</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
    <span class="n">L_y_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">L_x_noise</span><span class="p">,</span> <span class="n">L_y_noise</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">L_y_noise_fit</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">)</span>
    <span class="n">L_y_cleaned</span> <span class="o">=</span> <span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">-</span><span class="n">L_y_noise_fit</span>
    <span class="k">if</span> <span class="n">show_spectra</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_noise</span><span class="p">,</span> <span class="n">L_y_noise</span><span class="p">,</span> <span class="s1">&#39;b*&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;noise areas&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_noise_fit</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;polynomial fit&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">figure_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_fit_noise</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_boundary</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">figure_counter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">x_cut</span><span class="p">,</span> <span class="n">figure_counter</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_boundary</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">L_y_noise_fit</span><span class="p">,</span> <span class="n">figure_counter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">L_y_noise_fit</span><span class="p">,</span> <span class="n">x_cut</span><span class="p">,</span> <span class="n">figure_counter</span><span class="p">)</span></div>


<span class="c1">############################################################################################    </span>

<div class="viewcode-block" id="fit_gausse">
<a class="viewcode-back" href="../fitting_procedure.html#analyze_run.fit_gausse">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_gausse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Function used to define the Gaussian shape in Alpaga.</span>
<span class="sd">    </span>
<span class="sd">    y = intensity * np.exp(-((x - lambda_0) / waist) ** 2)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: list</span>
<span class="sd">        The x values.</span>
<span class="sd">    intensity: float</span>
<span class="sd">        The Gaussian intensity, the parameter targeted by the whole procedure.</span>
<span class="sd">    lambda_0: float</span>
<span class="sd">        The position of the Gaussian maximum.</span>
<span class="sd">    waist: float</span>
<span class="sd">        The waist of the Gaussian.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y: list</span>
<span class="sd">        The computed Gaussian values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">y</span><span class="o">=</span><span class="n">intensity</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">lambda_0</span><span class="p">)</span><span class="o">/</span><span class="n">waist</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>


<span class="c1">############################################################################################    </span>

<div class="viewcode-block" id="intensity_from_gaussian_integral">
<a class="viewcode-back" href="../fitting_procedure.html#analyze_run.intensity_from_gaussian_integral">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">intensity_from_gaussian_integral</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Extract the Gaussian intensity using the integration method. </span>
<span class="sd">    The integral is computed using the numpy.trapz function. </span>
<span class="sd">    The intensity is then given by: ::</span>
<span class="sd">    </span>
<span class="sd">        I0 = integral_value / (waist * np.sqrt(np.pi))</span>
<span class="sd">    </span>
<span class="sd">    Note that in this procedure, no uncertainty calculations are yet implemented. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L_x_cleaned: list</span>
<span class="sd">        The x-axis used to compute the integral. </span>
<span class="sd">        This axis should contain at least the Gaussian peak.</span>
<span class="sd">    L_y_cleaned: list</span>
<span class="sd">        The y-axis used to compute the integral. </span>
<span class="sd">        Usually, this is the output obtained from the :ref:`alpaga.remove_noise function&lt;remove_noise_section&gt;`. </span>
<span class="sd">        Apart from the Gaussian curve, the other values should be as close to zero as possible. </span>
<span class="sd">        Since the integration is performed over the entire list, non-zero values may affect the final intensity if their average is not zero.</span>
<span class="sd">    lambda_0: float</span>
<span class="sd">        Unused. This input is kept only for consistency with other methods.</span>
<span class="sd">    waist: float</span>
<span class="sd">        The waist of the Gaussian, used to extract the Gaussian intensity from the integral value. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    I0: float</span>
<span class="sd">        The computed Gaussian intensity.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">integral_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">L_x_cleaned</span><span class="p">)</span>
    <span class="c1"># int exp(-alpha x**2) = sqrt(pi/alpha)</span>
    <span class="c1"># We use: I(x) = I0 exp(- (x-lambda_0)/waist))**2)</span>
    <span class="c1"># int I0 exp(- (x-lambda_0)/waist))**2) = I0 waist sqrt(pi)</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="n">integral_value</span><span class="o">/</span><span class="p">(</span><span class="n">waist</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="k">return</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span></div>


<span class="c1">############################################################################################    </span>

<div class="viewcode-block" id="fit_gaussian_from_noise">
<a class="viewcode-back" href="../fitting_procedure.html#analyze_run.fit_gaussian_from_noise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_gaussian_from_noise</span><span class="p">(</span><span class="n">L_x</span><span class="p">,</span> <span class="n">L_y</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="p">[</span><span class="mi">380</span><span class="p">,</span> <span class="mi">395</span><span class="p">,</span> <span class="mi">419</span><span class="p">,</span> <span class="mi">433</span><span class="p">],</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">method_fit</span><span class="o">=</span><span class="s1">&#39;fit_gauss&#39;</span><span class="p">,</span>
                            <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">395</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">410</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span> <span class="n">lambda_0_ref</span><span class="o">=</span><span class="mi">403</span><span class="p">,</span> <span class="n">waist_ref</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">exclu_zone</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function returns the intensity *I0*, the maximum position *lambda_0*, and the width *waist* </span>
<span class="sd">    of the Gaussian in *L_y*. The procedure first removes the noise using </span>
<span class="sd">    :ref:`alpaga.remove_noise function&lt;remove_noise_section&gt;`, and then extracts the intensity.  </span>
<span class="sd">    Two methods are available to extract the intensity:</span>

<span class="sd">    1) If *method_fit* is set to &#39;fit_gauss&#39;:</span>
<span class="sd">        </span>
<span class="sd">        The intensity is extracted using *scipy.optimize.curve_fit*: ::</span>
<span class="sd">                    </span>
<span class="sd">            p, q = curve_fit(fit_gausse, L_x_cleaned, L_y_cleaned, bounds=bounds_fit_gausse) </span>
<span class="sd">            I0, lambda_0, waist = p[0], p[1], p[2]</span>
<span class="sd">                </span>
<span class="sd">        Here, *fit_gausse* is defined in the analyze_run.fit_gausse function. The x and y inputs are the outputs of the cleaning </span>
<span class="sd">        procedure (see :ref:`analyze_run.remove_noise function&lt;remove_noise_section&gt;`), and the bounds </span>
<span class="sd">        are given by the *bounds_fit_gausse* parameter.  </span>
<span class="sd">        This method returns the Gaussian intensity *I0*, the central wavelength *lambda_0*, and the </span>
<span class="sd">        width *waist*.  </span>
<span class="sd">        This approach is the most versatile and should generally be used first to characterize your </span>
<span class="sd">        experimental laser conditions (*lambda_0* and *waist*).</span>

<span class="sd">    2) If *method_fit* is set to &#39;fit_gauss_w_exclu&#39;:</span>
<span class="sd">        </span>
<span class="sd">        Same method as above, but with an exclusion zone (for example, if a Hyper Raman band is close </span>
<span class="sd">        to the SHG signal).  </span>
<span class="sd">        You must specify the exclusion zone with *exclu_zone = [X_min, X_max]*.</span>
<span class="sd">                </span>
<span class="sd">    3) If *method_fit* is set to &#39;integral_gauss&#39;:</span>
<span class="sd">        </span>
<span class="sd">        The intensity is extracted using *analyze_run.intensity_from_gaussian_integral*: ::</span>
<span class="sd">                    </span>
<span class="sd">            I0 = intensity_from_gaussian_integral(L_x_cleaned, L_y_cleaned, lambda_0, waist)</span>
<span class="sd">                </span>
<span class="sd">        Here, *lambda_0* and *waist* are set by the parameters *lambda_0_ref* and *waist_ref*.  </span>
<span class="sd">        Note that *lambda_0_ref* does not affect the result (*I0*); it is only used for plotting.  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L_x: list</span>
<span class="sd">        The x-axis data, used for noise removal and fitting.  </span>
<span class="sd">    L_y: list</span>
<span class="sd">        The y-axis data where the Gaussian intensity should be extracted.  </span>
<span class="sd">    l_cut: list of float</span>
<span class="sd">        [Optional] Parameters used for noise removal (see :ref:`alpaga.remove_noise function&lt;remove_noise_section&gt;`).  </span>
<span class="sd">    order_fit_noise: int</span>
<span class="sd">        [Optional] Order of the polynomial used for noise removal.  </span>
<span class="sd">    method_fit: str</span>
<span class="sd">        [Optional] The method used to extract the intensity once noise is removed.  </span>
<span class="sd">    bounds_fit_gausse: list</span>
<span class="sd">        [Optional] Bounds for the free parameters in the &#39;fit_gauss&#39; method.  </span>
<span class="sd">        Narrowing the parameter ranges avoids problems with low Gaussian intensity, where the fit </span>
<span class="sd">        may increase the width instead of decreasing *I0*.  </span>
<span class="sd">        Example: to restrict *lambda_0* between 401 and 405, and *waist* between 2 and 3, use  </span>
<span class="sd">        *bounds_fit_gausse = ([0, 401, 1], [np.inf, 405, 3])*.  </span>
<span class="sd">        See *scipy.optimize.curve_fit* documentation for more details.  </span>
<span class="sd">    lambda_0_ref: float</span>
<span class="sd">        [Optional] Reference value of *lambda_0* for the &#39;integral_gauss&#39; method.  </span>
<span class="sd">        This has no impact on the result but affects plotting.  </span>
<span class="sd">    waist_ref: float</span>
<span class="sd">        [Optional] Reference value of *waist* for the &#39;integral_gauss&#39; method.  </span>
<span class="sd">        This has a direct impact on *I0*. Choose carefully (see :ref:`polarisation_procedure_page`).  </span>
<span class="sd">    exclu_zone: list of float</span>
<span class="sd">        [Optional] Pair of floats defining the exclusion zone for &#39;fit_gauss_w_exclu&#39;.  </span>
<span class="sd">    show_spectra: str</span>
<span class="sd">        [Optional] If &#39;all&#39;, plots figures to check results. Otherwise, no figures are shown.  </span>
<span class="sd">    figure_counter: int</span>
<span class="sd">        [Optional] The number assigned to the first figure.  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L_para_gauss: list</span>
<span class="sd">        Gaussian parameters [I0, lambda_0, waist].  </span>
<span class="sd">        *I0*: Gaussian intensity  </span>
<span class="sd">        *lambda_0*: central wavelength  </span>
<span class="sd">        *waist*: Gaussian width  </span>
<span class="sd">    L_err: list</span>
<span class="sd">        Associated errors [err_I0, err_lambda_0, err_waist].  </span>
<span class="sd">        No errors are defined for the &#39;integral_gauss&#39; method; in this case, the error list contains zeros.  </span>
<span class="sd">    figure_counter: int</span>
<span class="sd">        Updated figure counter for subsequent plots.  </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See the tutorial for detailed examples. A minimal workflow is: ::</span>
<span class="sd">    </span>
<span class="sd">        # Define the directory where the data are stored</span>
<span class="sd">        directory = os.path.join(WORK_DIR, &#39;Eau_V_Spectres&#39;) </span>
<span class="sd">        </span>
<span class="sd">        # Extract Alpaga parameters describing the dataset</span>
<span class="sd">        prefix_file, L_files_angles, N_iter, extension = alpaga.find_angle_iter_from_dir(directory)</span>

<span class="sd">        # Select one acquisition</span>
<span class="sd">        names = os.path.join(directory, prefix_file) + &#39;_&#39; + L_files_angles[0] </span>
<span class="sd">        </span>
<span class="sd">        # Clean the acquisition from spikes and average it over N_iter</span>
<span class="sd">        L_lambda, L_spectra, _ = alpaga.averaging_and_cleaning(</span>
<span class="sd">            names, N_iter, extension=&#39;.dat&#39;, type_cleaning=&#39;mean&#39;,</span>
<span class="sd">            L_mean_cleaning_n=[1, 1, 1, 3], L_mean_cleaning_evo_max=[2, 1.5, 1.3, 1.3],</span>
<span class="sd">            show_spectra=False, figure_counter=1</span>
<span class="sd">        )</span>
<span class="sd">        </span>
<span class="sd">        # Remove noise and extract Gaussian parameters</span>
<span class="sd">        intensity, lambda_0, omega, figure_counter = Alpaga.analyze_run.fit_gaussian_from_noise(</span>
<span class="sd">            L_lambda, L_spectra, l_cut=[380, 399, 414, 431], order_fit_noise=4,</span>
<span class="sd">            bounds_fit_gausse=([0, 395, 1], [np.inf, 410, 25]), show_spectra=&#39;all&#39;</span>
<span class="sd">        )</span>
<span class="sd">        </span>
<span class="sd">        print(intensity, lambda_0, omega)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x</span><span class="p">,</span> <span class="n">L_y</span><span class="p">)</span>
        <span class="n">figure_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        
    <span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">remove_noise</span><span class="p">(</span><span class="n">L_x</span><span class="p">,</span> <span class="n">L_y</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> 
                                                            <span class="n">return_fit_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="n">show_spectra</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="n">figure_counter</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">method_fit</span> <span class="o">==</span> <span class="s1">&#39;fit_gauss&#39;</span><span class="p">:</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">fit_gausse</span><span class="p">,</span> <span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds_fit_gausse</span><span class="p">)</span> 
        <span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">L_para_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">])</span>
        
        <span class="n">perr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">I0_serr</span><span class="p">,</span> <span class="n">lambda_0_serr</span><span class="p">,</span> <span class="n">waist_serr</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">perr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">L_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I0_serr</span><span class="p">,</span> <span class="n">lambda_0_serr</span><span class="p">,</span> <span class="n">waist_serr</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">fit_gausse</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">))</span>
            
    <span class="k">elif</span> <span class="n">method_fit</span> <span class="o">==</span> <span class="s1">&#39;fit_gauss_w_exclu&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exclu_zone</span> <span class="o">==</span> <span class="kc">False</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No exclusion zone defined&quot;</span><span class="p">)</span>
        <span class="c1"># find where to make the cut to define the exclusion zone</span>
        <span class="n">N_lambda</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">)</span>
        <span class="n">KKK</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">trotter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">trotter</span><span class="o">&lt;</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">KKK</span><span class="o">&gt;</span><span class="n">N_lambda</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">L_x_cleaned</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">exclu_zone</span><span class="p">[</span><span class="n">trotter</span><span class="p">]:</span>
                <span class="n">x_cut</span><span class="p">[</span><span class="n">trotter</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">KKK</span><span class="p">)</span>
                <span class="n">trotter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">KKK</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#define new list without exclusion list</span>
        <span class="n">L_x_cleaned_exclu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">L_y_cleaned_exclu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">L_y_cleaned</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="mi">0</span><span class="p">)</span>
        
            
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">fit_gausse</span><span class="p">,</span> <span class="n">L_x_cleaned_exclu</span><span class="p">,</span> <span class="n">L_y_cleaned_exclu</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds_fit_gausse</span><span class="p">)</span> 
        <span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">L_para_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">])</span>
        
        <span class="n">perr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">I0_serr</span><span class="p">,</span> <span class="n">lambda_0_serr</span><span class="p">,</span> <span class="n">waist_serr</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">perr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">L_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I0_serr</span><span class="p">,</span> <span class="n">lambda_0_serr</span><span class="p">,</span> <span class="n">waist_serr</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">fit_gausse</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">L_y_cleaned</span><span class="p">[</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="s1">&#39;r*&#39;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">method_fit</span> <span class="o">==</span> <span class="s1">&#39;integral_gauss&#39;</span><span class="p">:</span>
        <span class="n">I0</span> <span class="o">=</span> <span class="n">intensity_from_gaussian_integral</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_y_cleaned</span><span class="p">,</span> <span class="n">lambda_0_ref</span><span class="p">,</span> <span class="n">waist_ref</span><span class="p">)</span>
        <span class="n">L_para_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0_ref</span><span class="p">,</span> <span class="n">waist_ref</span><span class="p">])</span>
        <span class="n">L_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">show_spectra</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figure_counter</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">fit_gausse</span><span class="p">(</span><span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">lambda_0_ref</span><span class="p">,</span> <span class="n">waist_ref</span><span class="p">))</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;WARNING: method_fit argument not valid. Possible value: &#39;fit_gauss&#39; or &#39;integral_gauss&#39;&quot;</span><span class="p">)</span>
        
    <span class="n">figure_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">fit_noise</span> <span class="o">==</span> <span class="kc">False</span> <span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">L_para_gauss</span><span class="p">,</span> <span class="n">L_err</span><span class="p">,</span> <span class="n">figure_counter</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">L_para_gauss</span><span class="p">,</span> <span class="n">L_err</span><span class="p">,</span> <span class="n">L_x_cleaned</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">figure_counter</span><span class="p">)</span></div>

    

<span class="c1">############################################################################################    </span>
<span class="c1">############################  Polarisation procedure  ######################################</span>
<span class="c1">############################################################################################      </span>

<div class="viewcode-block" id="polarisation_intensity">
<a class="viewcode-back" href="../polarisation_procedure.html#analyze_run.polarisation_intensity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">polarisation_intensity</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">L_filename</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">prefix_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">L_files_angles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">N_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span> 
                           <span class="n">fct_name</span><span class="o">=</span><span class="n">standard_file_name</span><span class="p">,</span> 
                           <span class="n">type_cleaning</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> 
                           <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> 
                           <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> 
                           <span class="n">automatic_l_cut</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="p">[</span><span class="mi">380</span><span class="p">,</span> <span class="mi">395</span><span class="p">,</span> <span class="mi">419</span><span class="p">,</span> <span class="mi">433</span><span class="p">],</span> 
                           <span class="n">l_cut_n_n2</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                           <span class="n">order_fit_noise</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
                           <span class="n">method_fit_first</span><span class="o">=</span><span class="s1">&#39;fit_gauss&#39;</span><span class="p">,</span> 
                           <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">395</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">410</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span> 
                           <span class="n">lambda_0_ref</span><span class="o">=</span><span class="mi">403</span><span class="p">,</span> 
                           <span class="n">waist_ref</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
                           <span class="n">exclu_zone</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">fixed_para_gauss_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                           <span class="n">method_fit_second</span><span class="o">=</span><span class="s1">&#39;fit_gauss&#39;</span><span class="p">,</span> 
                           <span class="n">save_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                           <span class="n">name_save_result</span><span class="o">=</span><span class="s1">&#39;./post_prod_results.p&#39;</span><span class="p">,</span> 
                           <span class="n">waiting_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">show_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">L_input_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">,</span> <span class="s1">&#39;L_filename&#39;</span><span class="p">,</span> <span class="s1">&#39;prefix_file&#39;</span><span class="p">,</span> <span class="s1">&#39;L_files_angles&#39;</span><span class="p">,</span> <span class="s1">&#39;N_iter&#39;</span><span class="p">,</span> <span class="s1">&#39;extension&#39;</span><span class="p">,</span> <span class="s1">&#39;type_cleaning&#39;</span><span class="p">,</span> <span class="s1">&#39;L_mean_cleaning_n&#39;</span><span class="p">,</span> <span class="s1">&#39;L_mean_cleaning_evo_max&#39;</span><span class="p">,</span> <span class="s1">&#39;automatic_l_cut&#39;</span><span class="p">,</span> <span class="s1">&#39;l_cut&#39;</span><span class="p">,</span> <span class="s1">&#39;l_cut_n_n2&#39;</span><span class="p">,</span> <span class="s1">&#39;order_fit_noise&#39;</span><span class="p">,</span> <span class="s1">&#39;method_fit_first&#39;</span><span class="p">,</span> <span class="s1">&#39;bounds_fit_gausse&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda_0_ref&#39;</span><span class="p">,</span> <span class="s1">&#39;waist_ref&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed_para_gauss_fit&#39;</span><span class="p">,</span> <span class="s1">&#39;method_fit_second&#39;</span><span class="p">,</span> <span class="s1">&#39;save_result&#39;</span><span class="p">,</span> <span class="s1">&#39;name_save_result&#39;</span><span class="p">,</span> <span class="s1">&#39;waiting_time&#39;</span><span class="p">,</span> <span class="s1">&#39;show_figure&#39;</span><span class="p">]</span>
    
    <span class="n">L_post_prod</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_filename</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">L_filename</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;ERROR: if you provide L_filename, it should be a list of list containing the filenames&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I will use your L_filename to find the files.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_files_angles</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You have to define a L_files_angles!&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L_files_angles=&#39;</span><span class="p">,</span> <span class="n">L_files_angles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_iter</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You have to define N_iter!&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_iter=&#39;</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prefix_file</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">prefix_file</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extension</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">extension</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="n">L_filename_K</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">directory</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No directory given, I will use the input from prefix_file, L_files_angles, N_iter and extension.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix_file</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">L_files_angles</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">N_iter</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">extension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: since no directory has been given, I need values for the optional parameters: prefix_file, L_files_angles, N_iter and extension. Please provide all of them or use directory=our_directory_where_the_data_are.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prefix_file</span> <span class="ow">and</span> <span class="n">L_files_angles</span> <span class="ow">and</span> <span class="n">N_iter</span> <span class="ow">and</span> <span class="n">extension</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I will use your custom parameters for prefixe, L_files_angles, N_iter and extension.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefix_file_t</span><span class="p">,</span> <span class="n">L_files_angles_t</span><span class="p">,</span> <span class="n">N_iter_t</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">find_angle_iter_from_dir</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="n">extension</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prefix_file</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I will use your custom general prefixe instead of the one found in the directory:&#39;</span><span class="p">,</span> <span class="n">prefix_file</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prefix_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">prefix_file_t</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">L_files_angles</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I will use your custom L_files_angles instead of the one found in the directory:&#39;</span><span class="p">,</span> <span class="n">L_files_angles</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">L_files_angles</span> <span class="o">=</span> <span class="n">L_files_angles_t</span>

                <span class="k">if</span> <span class="n">N_iter</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I will use your custom N_iter instead of the one found in the directory:&#39;</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">N_iter</span> <span class="o">=</span> <span class="n">N_iter_t</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The prefix for all the file are: &quot;&#39;</span> <span class="o">+</span> <span class="n">prefix_file</span> <span class="o">+</span> <span class="s1">&#39;&quot; with &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">N_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; iter. The angle are &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">L_files_angles</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. The extension is: &#39;</span> <span class="o">+</span> <span class="n">extension</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">show_figure</span><span class="p">:</span>
        <span class="n">show_figure_fit_gauss</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">show_figure_fit_gauss</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># save input</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">directory</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_filename</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;prefix_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix_file</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;N_iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_iter</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_files_angles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_files_angles</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;extension&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extension</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;type_cleaning&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_cleaning</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_mean_cleaning_n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_mean_cleaning_n</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_mean_cleaning_evo_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_mean_cleaning_evo_max</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;automatic_l_cut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">automatic_l_cut</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;l_cut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_cut</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;l_cut_n_n2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_cut_n_n2</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;order_fit_noise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">order_fit_noise</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;bounds_fit_gausse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds_fit_gausse</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;lambda_0_ref&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda_0_ref</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;waist_ref&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">waist_ref</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;method_fit_first&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method_fit_first</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;method_fit_second&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method_fit_second</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;fixed_para_gauss_fit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed_para_gauss_fit</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;save_result&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_result</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;name_save_result&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_save_result</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;waiting_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">waiting_time</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;exclu_zone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exclu_zone</span>
    
    <span class="c1"># the first polarisation analysis</span>
    <span class="n">N_angle</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_files_angles</span><span class="p">)</span>
    <span class="n">L_intensity_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
    <span class="n">L_lambda_0_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
    <span class="n">L_waist_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
    
    <span class="n">L_intensity_angle_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
    <span class="n">L_lambda_0_angle_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
    <span class="n">L_waist_angle_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
    
    <span class="n">LL_noise_param</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">KKK</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_angle</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_filename</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">L_filename_K</span> <span class="o">=</span> <span class="n">L_filename</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">clear_output</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Angle:&#39;</span><span class="p">,</span> <span class="n">L_files_angles</span><span class="p">[</span><span class="n">KKK</span><span class="p">])</span>
        
        <span class="n">names</span> <span class="o">=</span> <span class="n">prefix_file</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">L_files_angles</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span>
        <span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">averaging_and_cleaning</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">,</span> <span class="n">L_filename</span><span class="o">=</span><span class="n">L_filename_K</span><span class="p">,</span> <span class="n">fct_name</span><span class="o">=</span><span class="n">fct_name</span><span class="p">,</span> <span class="n">type_cleaning</span><span class="o">=</span><span class="n">type_cleaning</span><span class="p">,</span> <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="n">L_mean_cleaning_n</span><span class="p">,</span> <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="n">L_mean_cleaning_evo_max</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="n">extension</span><span class="p">)</span>
        
        <span class="n">L_para_gauss</span><span class="p">,</span> <span class="n">L_err</span><span class="p">,</span> <span class="n">L_x_fit_noise</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">fit_gaussian_from_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">method_fit</span><span class="o">=</span><span class="n">method_fit_first</span><span class="p">,</span> <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="n">bounds_fit_gausse</span><span class="p">,</span> <span class="n">lambda_0_ref</span><span class="o">=</span><span class="n">lambda_0_ref</span><span class="p">,</span> <span class="n">waist_ref</span><span class="o">=</span><span class="n">waist_ref</span><span class="p">,</span> <span class="n">exclu_zone</span><span class="o">=</span><span class="n">exclu_zone</span><span class="p">,</span> <span class="n">fit_noise</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="n">show_figure_fit_gauss</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">intensity</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span> <span class="o">=</span> <span class="n">L_para_gauss</span>
        <span class="k">if</span> <span class="n">automatic_l_cut</span><span class="p">:</span> <span class="c1"># the second run with automatic l_cut</span>
            <span class="n">l_cut_temp</span><span class="o">=</span><span class="p">[</span><span class="n">lambda_0</span><span class="o">-</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">waist</span><span class="p">,</span> <span class="n">lambda_0</span><span class="o">-</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">waist</span><span class="p">,</span> <span class="n">lambda_0</span><span class="o">+</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">waist</span><span class="p">,</span> <span class="n">lambda_0</span><span class="o">+</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">waist</span><span class="p">]</span>
            <span class="n">L_para_gauss</span><span class="p">,</span> <span class="n">L_err</span><span class="p">,</span> <span class="n">L_x_fit_noise</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">fit_gaussian_from_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut_temp</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">method_fit</span><span class="o">=</span><span class="n">method_fit_first</span><span class="p">,</span> <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="n">bounds_fit_gausse</span><span class="p">,</span> <span class="n">lambda_0_ref</span><span class="o">=</span><span class="n">lambda_0_ref</span><span class="p">,</span> <span class="n">waist_ref</span><span class="o">=</span><span class="n">waist_ref</span><span class="p">,</span> <span class="n">fit_noise</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="n">show_figure_fit_gauss</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="n">figure_counter</span><span class="p">)</span>
            <span class="n">intensity</span><span class="p">,</span> <span class="n">lambda_0</span><span class="p">,</span> <span class="n">waist</span> <span class="o">=</span> <span class="n">L_para_gauss</span>
        
        <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">L_x_fit_noise</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">)</span>
        <span class="n">LL_noise_param</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        
        <span class="n">L_intensity_angle</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensity</span>
        <span class="n">L_lambda_0_angle</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda_0</span>
        <span class="n">L_waist_angle</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">waist</span>
        
        <span class="n">L_intensity_angle_err</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">L_lambda_0_angle_err</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_err</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">L_waist_angle_err</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_err</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">show_figure</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">waiting_time</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span> <span class="c1"># short pause so that the user can see the plots.</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">waiting_time</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_intensity_angle</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_intensity_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_intensity_angle_err</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_lambda_0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_lambda_0_angle</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_lambda_0_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_lambda_0_angle_err</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_waist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_waist_angle</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_waist_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_waist_angle_err</span>
    <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;LL_noise_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LL_noise_param</span>
    
    
    <span class="c1"># the second polarisation analysis with fixed lambda_0 and waist</span>
    <span class="k">if</span> <span class="n">fixed_para_gauss_fit</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;fit_gauss&#39;</span> <span class="ow">or</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">L_intensity_angle_fit_gauss_fixed_para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
            <span class="n">L_intensity_angle_fit_gauss_fixed_para_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
        
            
        <span class="k">if</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;integral_gauss&#39;</span> <span class="ow">or</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">L_intensity_angle_integral_gauss_fixed_para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
            <span class="n">L_intensity_angle_integral_gauss_fixed_para_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
        
        <span class="n">lambda_0_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_lambda_0_angle</span><span class="p">)</span> 
        <span class="n">waist_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_waist_angle</span><span class="p">)</span> 
        <span class="n">L_intensity_angle_fixed_para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_angle</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">automatic_l_cut</span><span class="p">:</span> <span class="c1"># reset the l_cut using the automatic scheme</span>
            <span class="n">l_cut</span><span class="o">=</span><span class="p">[</span><span class="n">lambda_0_mean</span><span class="o">-</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">waist_mean</span><span class="p">,</span> <span class="n">lambda_0_mean</span><span class="o">-</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">waist_mean</span><span class="p">,</span> <span class="n">lambda_0_mean</span><span class="o">+</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">waist_mean</span><span class="p">,</span> <span class="n">lambda_0_mean</span><span class="o">+</span><span class="n">l_cut_n_n2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">waist_mean</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">KKK</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_angle</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_filename</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">L_filename_K</span> <span class="o">=</span> <span class="n">L_filename</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
            <span class="n">clear_output</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Second Run, Angle:&#39;</span><span class="p">,</span> <span class="n">L_files_angles</span><span class="p">[</span><span class="n">KKK</span><span class="p">])</span>
            <span class="n">figure_counter</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">prefix_file</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">L_files_angles</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span>
            <span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">averaging_and_cleaning</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">N_iter</span><span class="p">,</span> <span class="n">L_filename</span><span class="o">=</span><span class="n">L_filename_K</span><span class="p">,</span> <span class="n">fct_name</span><span class="o">=</span><span class="n">fct_name</span><span class="p">,</span> <span class="n">type_cleaning</span><span class="o">=</span><span class="n">type_cleaning</span><span class="p">,</span> <span class="n">L_mean_cleaning_n</span><span class="o">=</span><span class="n">L_mean_cleaning_n</span><span class="p">,</span> <span class="n">L_mean_cleaning_evo_max</span><span class="o">=</span><span class="n">L_mean_cleaning_evo_max</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="n">extension</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">show_figure</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                
            <span class="k">if</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;fit_gauss&#39;</span> <span class="ow">or</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="n">L_para_gauss</span><span class="p">,</span> <span class="n">L_err</span><span class="p">,</span> <span class="n">L_x_fit_noise</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">fit_gaussian_from_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">method_fit</span><span class="o">=</span><span class="s1">&#39;fit_gauss&#39;</span><span class="p">,</span> <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">lambda_0_mean</span><span class="o">-</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">waist_mean</span><span class="o">-</span><span class="mf">0.00001</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">lambda_0_mean</span><span class="o">+</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">waist_mean</span><span class="o">+</span><span class="mf">0.00001</span><span class="p">]),</span> <span class="n">lambda_0_ref</span><span class="o">=</span><span class="n">lambda_0_mean</span><span class="p">,</span> <span class="n">waist_ref</span><span class="o">=</span><span class="n">waist_mean</span><span class="p">,</span> <span class="n">fit_noise</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="n">show_figure_fit_gauss</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="n">figure_counter</span><span class="p">)</span>
                <span class="n">L_intensity_angle_fit_gauss_fixed_para</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_para_gauss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">L_intensity_angle_fit_gauss_fixed_para_err</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        
            <span class="k">if</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;integral_gauss&#39;</span> <span class="ow">or</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>    
                <span class="n">L_para_gauss</span><span class="p">,</span> <span class="n">L_err</span><span class="p">,</span> <span class="n">L_x_fit_noise</span><span class="p">,</span> <span class="n">L_fit_noise</span><span class="p">,</span> <span class="n">figure_counter</span> <span class="o">=</span> <span class="n">fit_gaussian_from_noise</span><span class="p">(</span><span class="n">L_lambda</span><span class="p">,</span> <span class="n">L_spectra</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="n">l_cut</span><span class="p">,</span> <span class="n">order_fit_noise</span><span class="o">=</span><span class="n">order_fit_noise</span><span class="p">,</span> <span class="n">method_fit</span><span class="o">=</span><span class="s1">&#39;integral_gauss&#39;</span><span class="p">,</span> <span class="n">bounds_fit_gausse</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">lambda_0_mean</span><span class="o">-</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">waist_mean</span><span class="o">-</span><span class="mf">0.00001</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">lambda_0_mean</span><span class="o">+</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">waist_mean</span><span class="o">+</span><span class="mf">0.00001</span><span class="p">]),</span> <span class="n">lambda_0_ref</span><span class="o">=</span><span class="n">lambda_0_mean</span><span class="p">,</span> <span class="n">waist_ref</span><span class="o">=</span><span class="n">waist_mean</span><span class="p">,</span> <span class="n">fit_noise</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">show_spectra</span><span class="o">=</span><span class="n">show_figure_fit_gauss</span><span class="p">,</span> <span class="n">figure_counter</span><span class="o">=</span><span class="n">figure_counter</span><span class="p">)</span>
                <span class="n">L_intensity_angle_integral_gauss_fixed_para</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_para_gauss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">L_intensity_angle_integral_gauss_fixed_para_err</span><span class="p">[</span><span class="n">KKK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_figure</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">waiting_time</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span> <span class="c1"># short pause so that the user can see the plots.</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">waiting_time</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;fit_gauss&#39;</span> <span class="ow">or</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_intensity_fit_gauss_fixed_para&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_intensity_angle_fit_gauss_fixed_para</span>
            <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_intensity_fit_gauss_fixed_para_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_intensity_angle_fit_gauss_fixed_para_err</span>
                
        <span class="k">if</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;integral_gauss&#39;</span> <span class="ow">or</span> <span class="n">method_fit_second</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_intensity_integral_gauss_fixed_para&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_intensity_angle_integral_gauss_fixed_para</span>
            <span class="n">L_post_prod</span><span class="p">[</span><span class="s1">&#39;L_intensity_integral_gauss_fixed_para_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_intensity_angle_integral_gauss_fixed_para_err</span>
                
        
    <span class="c1"># saving the results</span>
    <span class="k">if</span> <span class="n">save_result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The results will be saved at: &#39;</span> <span class="o">+</span> <span class="n">name_save_result</span> <span class="o">+</span> <span class="s1">&#39;. Please note that this will erase the file with the same name if it exist. Use the optional input name_save_result to change the name. Note that you SHOULD set the general path.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">name_save_result</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name_save_result</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">name_save_result</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span> <span class="p">)</span> <span class="k">as</span> <span class="n">pfile</span><span class="p">:</span> <span class="c1"># which makes sure that the file is properly closed after writing</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">L_post_prod</span><span class="p">,</span> <span class="n">pfile</span><span class="p">)</span>
        
        <span class="n">name_save_result_txt</span> <span class="o">=</span><span class="n">name_save_result</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span> 
        
        <span class="n">L_float</span> <span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">L_files_angles</span><span class="p">]</span>
        
        <span class="n">L_to_write</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">L_float</span><span class="p">,</span> <span class="n">L_intensity_angle</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">name_save_result_txt</span><span class="p">,</span> <span class="n">L_to_write</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;    &#39;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The results are not saved. Set save_result to True if you want to save them.&#39;</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">L_post_prod</span><span class="p">)</span></div>


<span class="c1">############################################################################################     </span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/alpaga_logo.svg" alt="Logo of Alpaga"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Alpaga</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">1. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file_management.html">2. File Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cleaning_averaging_spectra.html">3. Cleaning and Averaging Spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fitting_procedure.html">4. Fitting the Gaussian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../polarisation_procedure.html">5. Polarisation Procedure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis_SHS.html">6. SHS analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis_SSHG.html">7. SSHG analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_advice.html">8. Python advice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experimental_advice.html">9. Experimental and procedure advice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../for_developpers.html">10. For Developpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alpaga.html">11. Source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devs_page.html">12. Alpaga’s developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference.html">13. Reference</a></li>
</ul>


<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;L-GPL.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>